---
title: "MIMOSA Simulations"
format: 
  html: default
---

```{r,message=FALSE,warning=FALSE}

#loading MIMOSAy
#install.packages("devtools") #install devtools package
library(devtools) #load it
#install_github("RGLab/MIMOSA",ref="trunk") 
library(devtools) 
library(ggplot2)
library(MIMOSA) 
library(dplyr)
library(tidyr)
library(pROC)
library(cowplot)
library(tibble)
```

Parameters

Unstimulated cells will react the same whether they are responders or not so mean is the same. Stimulated reactions differ when it is a responder vs. a non-responder.

```{r}
set.seed(2025)
source("R/calculate_params.R")
source("R/simulate_data.R")
source("R/prepare_for_mimosa.R")
source("R/fit_MIMOSA.R")
source("R/average_ROC_results.R")
source("R/ROC_curve.R")
source("R/fishers_curve.R")
source("R/LRT_curve.R")
# source("R/simulate_all.R")
source("R/simulate_data_random.R")
```

```{r}
# Parameter lists
# n_samples_list <- c( 200)        # Number of participants
# N_list        <- c(10e3, 25e3, 50e3)     # Number of cells per sample
# w_list       <- c(0.2, 0.5, 0.7)       # Probability of responder
# f_list       <- c(1, 1.5, 2)           # Inflation factor
# c_list       <- c(1, 2, 3)             # Concentration
# mu_u_NR <- c(0.05, 0.10)          # Means for non-responders (unstimulated)
# mu_u_R  <- c(0.10, 0.25, 0.30)    # Means for responders (unstimulated)
# n_runs_list    <- 10                    # Number of simulation runs

n_samples_list <- c( 200)        # Number of participants
N_list        <- c(50e3)     # Number of cells per sample
w_list       <- c(0.5)       # Probability of responder
f_list       <- c(4)           # Inflation factor
#c_R_list  <- c(400)# Concentration
#c_NR_list<-c(26345)
mu_u_NR <- c(6.467642e-05)          # Means for non-responders (unstimulated)
mu_u_R  <- c(6.467642e-05)    # Means for responders (unstimulated), let it be the same
n_runs   <- 10               # Number of simulation runs
c_stim_list       <- c(85000)     # Concentration
c_unstim_list       <- c(23000)      # Concentration
```

```{r}
#| eval: false
# Run analysis
for (n_samples in n_samples_list){
        for (N in N_list) {
            for (w in w_list) {
                for (f in f_list) {
                    for (c_u in c_unstim_list) {
                        for (c_s in c_stim_list) {
                        print("=== Running Simulation with Parameters ===")
                        print(paste("Parameters: n_samples =", n_samples, ", N =", N, ", w =", w, ", f =", f, ", c_u =", c_u, ", c_s =", c_s))
                        # Store results from multiple runs
                        # Store results from multiple runs
                        all_roc_mimosa <- list()
                        all_roc_fisher <- list()
                        
                        # Run multiple simulations
                        for(run in 1:n_runs) {
                            
                            # Get simulation data
                            params <- calculated_params(mu_u_NR, mu_u_R, f, c_u, c_s)
                            dat <- simulate_data(n_samples, w, params, N, run)
                            # Fit MIMOSA model
                            E <- prepare_for_mimosa(dat$data)
                            if (is.null(E)) {
                                print("E is NULL â€“ skipping this combination")
                                next
                            }
                            print("fitting MIMOSA model")
                            #browser()
                            fit <- fit_MIMOSA(E)
                             # Calculate ROC results
                             roc_result <- ROC_curve(fit, dat)
                             roc_fisher <- fishers_curve(dat)

                            all_roc_mimosa[[run]] <- roc_result
                            all_roc_fisher[[run]] <- roc_fisher
                        }
                        # Average the curves
                        avg_roc_mimosa <- average_roc_curves(all_roc_mimosa)
                        avg_roc_fisher <- average_roc_curves(all_roc_fisher)
                        p <- plot_curves(avg_mimosa,avg_fisher,n_samples,
                                         auc_mimosa = avg_mimosa$auc,auc_fisher = avg_fisher$auc
                         )
                        filename<-                                sprintf("plots/ROC_avg_ns%d_N%.0f_w%.2f_f%.0f_cR%.0f_cNR%.0f_runs%d.png",
                    n_samples, N, w, f, c_R, c_NR, n_runs)
                        ggsave(filename, plot = p, width = 8, height = 6, dpi = 300)
                     }
                 }
             }
         }
   }
 }
```

Plots the change in cell counts for the responders and non responders. This plot can be used to assessed if realistic data has been generated.code below.

```{r}
#| eval: false
plot_responder_comparison <- function(sim_result) {
  # Get data and responder status
  data <- sim_result$data
  responder_status <- sim_result$responder_status
  # Add responder label to data
   # Match responder_status to each SUBJECTID
  resp_map <- setNames(responder_status, unique(data$SUBJECTID))
  data$RESPONDER <- resp_map[data$SUBJECTID]
  data$RESPONDER <- ifelse(data$RESPONDER == 1, "Responder", "Non-Responder")
  data$STIMULATION <- factor(data$STIMULATION,
                            levels = c("Unstimulated", "Stimulated") )
 # Plot trend in cell counts 
 p1 <- ggplot(data, aes(x = STIMULATION, y = CYTNUM, color = RESPONDER)) +
   geom_line(aes(group = SUBJECTID), alpha = 0.6, linewidth = 0.5) +
    geom_point(size = 2, alpha = 0.8) +
    facet_wrap(~RESPONDER) +
    labs(
      title = "Cell Count Distribution by Responder Status",
      x = "Condition",
      y = "Number of Functional Cells",
      color = "Responder Status"
    ) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
    return(p1)
}

for (n_samples_val in n_samples_list) {
    for (N_val in N_list) {
        for (w_val in w_list) {
            for (f_val in f_list) {
                for (c_R_val in c_R_list) {
                     for (c_NR_val in c_NR_list) {
                          for(run in 1:n_runs) {
                    print(paste("Generating plot for:", "Run =", run
, ",n_samples =", n_samples_val, 
                               ", N =", N_val, ", w =", w_val, ", f =", f_val, ", c_R =", c_R_val, ", c_NR =", c_NR_val))                   
                    # Generate data
                    params <- calculated_params(mu_u_NR, mu_u_R, f_val, c_u,c_s)
                    dat <- simulate_data(n_samples_val, w_val, params, N_val, run)
                    # Plot the cell count distribution by responder status
                    plot <- plot_responder_comparison(dat)
                    # Save plot
                    filename <- sprintf(
                "plots/cell_counts%d_N%.0f_w%.2f_f%.0f_cR%.0f_cNR%.0f_run%d.png",
                n_samples_val, N_val, w_val, f_val, c_R_val, c_NR_val, run
              )
                    ggsave(filename, plot = plot, width = 12, height = 6, dpi = 300)
                             }
                    
                  }           
                }
            }
        }
    }
}

```

# Plot the empirical density for simulated data

```{r}
#| eval: false
# mode: (alpha - 1) / (alpha + beta - 2)
# their mode:
# 4.5 / 85 * 4e-4 = 2.12e-5
# Parameters
mode_u <- 2.12e-5
con <- 2.3e4
alpha_unstim <- 1 + mode_u * (con - 2)
beta_unstim <- con - alpha_unstim
mean_uns <- alpha_unstim / con


#mu_u_R  <- 0.0000529
#con     <- 18997
#alpha_unstim <- con * mu_u_R
#beta_unstim  <- con * (1 - mu_u_R) 

# Simulate Beta data
set.seed(2025)
df <- data.frame(empirical = rbeta(200, alpha_unstim, beta_unstim))

y_height <- 1.5e4
# Plot
library(ggplot2)
plot <- ggplot(df, aes(x = empirical)) +
  geom_histogram(aes(y = after_stat(density)),
                 binwidth = 2.3e-05, fill = "lightgrey", color = "black") +
  stat_function(fun = dbeta,
                args = list(shape1 = alpha_unstim, shape2 = beta_unstim),
                color = "blue", linetype = "dotdash", linewidth = 1.2) +
  labs(x = expression(paste("Empirical ", hat(p)[u])),
       y = "Density") +
  theme_bw() +
  coord_cartesian(xlim = c(0, 6e-04), ylim = c(0, 15000)) +
  scale_x_continuous(breaks = seq(0, 6e-04, by = 2e-04)) +
  scale_y_continuous(breaks = seq(0, 15000, by = 3000))

filename <- sprintf("plots/empirical_density.png")
ggsave(filename, plot = plot, width = 24, height = 12, dpi = 300)
```

```{r}
n_samples_list <- c(200)   # Number of participants
N_list        <- c(50e3)    # Number of cells per sample
w_list       <- c(0.5)      # Probability of responder
f_list       <- c(4)         # Inflation factor

mu_u_NR <- 6.467642e-05 

mu_u_R  <- c(0.00207)           # Means for responders

n_runs   <- 1           # Number of simulation runs


n_samples <- n_samples_list[1]
N         <- N_list[1]
w         <- w_list[1]
f         <- f_list[1]
c_u       <- c_unstim_list[1]
c_s       <- c_stim_list[1]
run <- 1
print("=== Running Simulation with Parameters ===")
print(paste("Parameters: n_samples =", n_samples, ", N =", N,
            ", w =", w, ", f =", f, ", c_u =", c_u, ", c_s =", c_s))

```

Here, we simulate results where we spike in noise, which is that for random subset of samples (participant-condition combination), we swop out the proportion of functional cells with a different value (magnitude), which varies from the unstimulated mean to double the stimulated mean.

We vary the proportion of samples spiked from 0% to 20%.

We then fit MIMOSA using both the EM and MCMC methods, and assess performance using the AUC (ability to identify the spiked samples) and the pseudo-trials ratio (measure of strength of prior information learned by MIMOSA about the data).

```{r}
#install.packages("cowplot")
set.seed(2025)
# Parameters
# whether to only run restricted parameter settings for testing
run_fast <- FALSE
spike_props <- c(0, 0.05, 0.1, 0.2)  # Proportion of spiked samples
magnitude_spikes <- c(mu_u_NR, mu_u_NR * 5, mu_u_NR * 5 * 2, mu_u_NR * 5 * 2)
N <- 2e4                               # Number of cells
n_samples <- 50                         # Number of samples
w <- 0.5                                 # weight for responders (example)
n_runs <- 10
mtd_vec <- c("EM", "mcmc")
# Storage
results_auc <- data.frame()
results_pseudo <- data.frame()
base_mu_u_NR <- mu_u_NR
base_mu_u_R  <- mu_u_R
if (run_fast) {
  spike_props <- spike_props[[1]]
  magnitude_spikes <- magnitude_spikes[[1]]
  mtd_vec <- "EM"
}
for (mtd in mtd_vec) {
  print(paste0("Method: ", mtd))
  for (spike in spike_props) {
    print(paste0("spike: ", spike))
    for (magnitude in magnitude_spikes) {
      print(paste0("magnitude: ", magnitude))
      for (run in seq_len(n_runs)) {
        print(paste0("run: ", run))
        mu_u_NR <- base_mu_u_NR
        mu_u_R  <- base_mu_u_R
        n_spike <- round(n_samples * spike)
        # Normal data 
        params <- calculate_params(base_mu_u_NR, base_mu_u_NR, f, c_u, c_s)
        dat <- simulate_data(n_samples, w, params, N, run)
        data_all <- dat$data
        responder_all <- dat$responder_status
        # Spiked data 
        # Spiked data (only if n_spike > 0)
        if (n_spike > 0) {
          rep_ind <- sample(seq_len(n_samples), size = n_spike, replace = FALSE)
          data_all <- dat$data
          data_all[rep_ind, "CYTNUM"] <- rbinom(n = n_spike, size = N, prob = magnitude)
          data_all[rep_ind, "NSUB"] <- N - data_all[["CYTNUM"]][rep_ind]
          responder_all <- dat$responder_status
        }
        # Fit MIMOSA 
        E <- prepare_for_mimosa(data_all)
        fit <- fit_MIMOSA(E, mtd = mtd)
        mimosa_obj <- fit$IL2
        res <- mimosa_obj@result
        em_failure <- mtd == "EM" && "params" %in% slotNames(res)
        if (em_failure) {
          beta_stim <- NA
          alpha_stim <- NA
          pseudo_ratio_stim <- NA
          beta_uns <- NA
          alpha_uns <- NA
          pseudo_ratio_uns <- NA
        } else if (mtd == "mcmc") {
          param_values <- res@params
          alpha_stim <- param_values[2, "alphas.1"]
          beta_stim  <- param_values[2, "alphas.0"]
          # Pseudo-trials ratio 
          pseudo_ratio_stim <- (alpha_stim + beta_stim - 2) / N
          # Pseudo-trials ratio 
          alpha_uns <- param_values[2, "alphau.1"]
          beta_uns  <- param_values[2, "alphau.0"]
          pseudo_ratio_uns <- (alpha_uns + beta_uns - 2) / N
        } else if (mtd == "EM") {
          stim_vec_par <- res@par.stim
          beta_stim <- stim_vec_par[1]
          alpha_stim <- stim_vec_par[2]
          pseudo_ratio_stim <- (alpha_stim + beta_stim - 2) / N
          uns_vec_par <- res@par.unstim
          beta_stim <- uns_vec_par[1]
          alpha_stim <- uns_vec_par[2]
          pseudo_ratio_uns <- (alpha_stim + beta_stim - 2) / N
        }
        # browser()
        # Get posterior probability that each sample is a responder
        prob_mat <- res@z
        if (length(unique(responder_all)) > 1 && !em_failure) {
          rn_vec <- rownames(prob_mat)
          rn_vec <- gsub("Treatment_Subject_", "", rn_vec)
          rn_vec <- gsub("_IL2.*", "", rn_vec)
          rn_vec <- as.numeric(rn_vec)
          roc_obj <- roc(
            response = responder_all[rn_vec],
            predictor = prob_mat[, "z2"],
            direction = "<"
          )
          auc_val <- as.numeric(roc_obj$auc)
          # get fisher's AUC now, too
          auc_fisher <- fishers_auc(
            .data = data_all, status = responder_all,
            alternative = "less"
          )
        } else {
          auc_val <- NA
        }

        # Save results
        results_auc <- rbind(results_auc, 
                            data.frame(spike_props = spike,
                                        magnitude_spikes = magnitude,
                                        AUC_MIMOSA = auc_val,
                                        AUC_Fisher = auc_fisher,
                                        method = mtd,
                                        run = run)
        )
        results_pseudo <- rbind(results_pseudo,
                                data.frame(spike_props = spike,
                                          magnitude_spikes = magnitude,
                                          PseudoRatioStim = pseudo_ratio_stim,
                                          PseudoRatioUnstim = pseudo_ratio_uns,
                                          method = mtd,
                                          run = run))
        rm(fit, mimosa_obj, res, E, data_all)
        gc()
      }
      print("------")
    }
    print("======")
  }
}
```

Use the EM algorithm plots for the pseudo-trials ratio (as it 
estimates the parameters directly), and the AUC plots for the MCMC method
(as there are fewer failed fits).

```{r}
for (mtd in mtd_vec) {
  # Plot  AUC vs Proportion of Spikes
  plot_tbl_auc <- results_auc |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(
      AUC_MIMOSA = mean(AUC_MIMOSA, na.rm = TRUE),
      AUC_Fisher = mean(AUC_Fisher, na.rm = TRUE),
      .groups = "drop"
      ) |>
    dplyr::ungroup() |>
    tidyr::pivot_longer(
      cols = c(AUC_MIMOSA, AUC_Fisher),
      names_to = "AUC_Type",
      values_to = "AUC"
    ) |>
    dplyr::filter(!is.nan(AUC)) |>
    dplyr::mutate(
      AUC_Type = gsub("AUC_", "", AUC_Type)
    )
  plot_auc <- ggplot(plot_tbl_auc, aes(x = spike_props, y = AUC, color = factor(magnitude_spikes), linetype = AUC_Type)) +
    geom_line(na.rm=TRUE) +
    labs(title = "AUC vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "AUC",
        color = "Magnitude") + 
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    )
  # Plot Pseudo-cells ratio vs Proportion of Spikes 
  plot_tbl_pseudo_stim <- results_pseudo |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(PseudoRatioStim = mean(PseudoRatioStim, na.rm = TRUE), .groups = "drop") |>
    dplyr::ungroup() |>
    dplyr::filter(!is.nan(PseudoRatioStim))
  max_ratio <- plot_tbl_pseudo_stim$PseudoRatioStim |> max(na.rm = TRUE)
  max_log <- ceiling(log10(max_ratio))
  min_ratio <- plot_tbl_pseudo_stim$PseudoRatioStim |> min(na.rm = TRUE)
  min_log <- floor(log10(min_ratio))
  break_vec <- seq(min_log, max_log, by = 1)
  plot_pseudo_stim <- ggplot(plot_tbl_pseudo_stim, aes(x = spike_props, y = PseudoRatioStim, color = factor(magnitude_spikes))) +
    geom_line(na.rm=TRUE) +
    labs(title = "Pseudo-trials ratio vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "Number of Pseudo cells/Real cells",
        color = "Magnitude") +
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    ) +
    scale_y_continuous(
      trans = "log10",
      breaks = 10^break_vec,
      labels = scales::comma(10^break_vec),
      limits = c(10^break_vec[1], 10^max(break_vec))
    )


  # Plot Pseudo-cells ratio vs Proportion of Spikes
  plot_tbl_pseudo_uns <- results_pseudo |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(PseudoRatioUnstim = mean(PseudoRatioUnstim, na.rm = TRUE), .groups = "drop") |>
    dplyr::ungroup() |>
    dplyr::filter(!is.nan(PseudoRatioUnstim))
  max_ratio_uns <- plot_tbl_pseudo_uns$PseudoRatioUnstim |> max(na.rm = TRUE)
  max_log_uns <- ceiling(log10(max_ratio_uns))
  min_ratio_uns <- plot_tbl_pseudo_uns$PseudoRatioUnstim |> min(na.rm = TRUE)
  min_log_uns <- floor(log10(min_ratio_uns))
  break_vec_uns <- seq(min_log_uns, max_log_uns, by = 1)
  plot_pseudo_uns <- ggplot(plot_tbl_pseudo_uns, aes(x = spike_props, y = PseudoRatioUnstim, color = factor(magnitude_spikes))) +
    geom_line(na.rm=TRUE) +
    labs(title = "Pseudo-trials ratio vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "Number of Pseudo cells/Real cells",
        color = "Magnitude") +
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    ) +
    scale_y_continuous(
      trans = "log10",
      breaks = 10^break_vec_uns,
      labels = scales::comma(10^break_vec_uns),
      limits = c(10^break_vec_uns[1], 10^max(break_vec_uns))
    )
  # Save
  ggsave(paste0("plots/plot_noise_", mtd, "_auc.png"), plot = plot_auc, width = 6, height = 4, dpi = 300)
  ggsave(paste0("plots/plot_noise_", mtd, "_pseudo_stim_.png"), plot = plot_pseudo_stim, width = 6, height = 4, dpi = 300)
  ggsave(paste0("plots/plot_noise_", mtd, "_pseudo_uns_.png"), plot = plot_pseudo_uns, width = 6, height = 4, dpi = 300)
}
```

Now, we consider spiking in data where some stimulated samples from responders have higher responses than the response.
We use exactly the same code as before, except that now we only allow the magnitude of the spike to be randomly swopped for stimulated samples.
We vary the proportion of samples spiked from 0% to 50% (higher range, as now this is not random swopout but targeted to responders only, who
may in real life has this sort of distribution due to e.g. sex differences) and the magnitude of the spike from the normal
stimulated mean to 10x the regular stimulated mean.

To make this work better, we use more samples (N=100).

```{r}
n_samples_active <- 100
magnitude_spikes_active <- c(mu_u_NR * 5, mu_u_NR * 5 * 2, mu_u_NR * 5 * 5, mu_u_NR * 5 * 10) 
spike_props_active <- c(0, 0.05, 0.1, 0.2, 0.5)    # Proportion of spiked samples
results_auc_active <- data.frame()
results_pseudo_active <- data.frame()
if (run_fast) {
  spike_props <- spike_props[[1]]
  magnitude_spikes <- magnitude_spikes[[1]]
  mtd_vec <- "EM"
}
for (mtd in mtd_vec) {
  print(paste0("Method: ", mtd))
  for (spike in spike_props_active) {
    print(paste0("spike: ", spike))
    for (magnitude in magnitude_spikes_active) {
      print(paste0("magnitude: ", magnitude))
      for (run in seq_len(n_runs)) {
        print(paste0("run: ", run))
        mu_u_NR <- base_mu_u_NR
        mu_u_R  <- base_mu_u_R
        n_spike <- round(n_samples_active * spike)
        # Normal data 
        params <- calculate_params(base_mu_u_NR, base_mu_u_NR, f, c_u, c_s)
        dat <- simulate_data(n_samples, w, params, N, run)
        data_all <- dat$data
        responder_all <- dat$responder_status
        # Spiked data 
        # Spiked data (only if n_spike > 0)
        if (n_spike > 0) {
          # only select stimulated indices, from responders
          rep_ind <- sample(seq(n_samples_active + 1, n_samples_active * 2), size = n_spike, replace = FALSE)
          data_all <- dat$data
          data_all[rep_ind, "CYTNUM"] <- rbinom(n = n_spike, size = N, prob = magnitude)
          data_all[rep_ind, "NSUB"] <- N - data_all[["CYTNUM"]][rep_ind]
          responder_all <- dat$responder_status
        }
        # Fit MIMOSA 
        E <- prepare_for_mimosa(data_all)
        fit <- fit_MIMOSA(E, mtd = mtd)
        mimosa_obj <- fit$IL2
        res <- mimosa_obj@result
        em_failure <- mtd == "EM" && "params" %in% slotNames(res)
        if (em_failure) {
          beta_stim <- NA
          alpha_stim <- NA
          pseudo_ratio_stim <- NA
          beta_uns <- NA
          alpha_uns <- NA
          pseudo_ratio_uns <- NA
        } else if (mtd == "mcmc") {
          param_values <- res@params
          alpha_stim <- param_values[2, "alphas.1"]
          beta_stim  <- param_values[2, "alphas.0"]
          # Pseudo-trials ratio 
          pseudo_ratio_stim <- (alpha_stim + beta_stim - 2) / N
          # Pseudo-trials ratio 
          alpha_uns <- param_values[2, "alphau.1"]
          beta_uns  <- param_values[2, "alphau.0"]
          pseudo_ratio_uns <- (alpha_uns + beta_uns - 2) / N
        } else if (mtd == "EM") {
          stim_vec_par <- res@par.stim
          beta_stim <- stim_vec_par[1]
          alpha_stim <- stim_vec_par[2]
          pseudo_ratio_stim <- (alpha_stim + beta_stim - 2) / N
          uns_vec_par <- res@par.unstim
          beta_stim <- uns_vec_par[1]
          alpha_stim <- uns_vec_par[2]
          pseudo_ratio_uns <- (alpha_stim + beta_stim - 2) / N
        }
        # browser()
        # AUC (using true labels: 0=normal, 1=spike) 
        labels <- c(rep(0, n_normal), rep(1, n_spike))
        # Get posterior probability that each sample is a responder
        prob_mat <- res@z
        if (length(unique(labels)) > 1 && !em_failure) {
          rn_vec <- rownames(prob_mat)
          rn_vec <- gsub("Treatment_Subject_", "", rn_vec)
          rn_vec <- gsub("_IL2.*", "", rn_vec)
          rn_vec <- as.numeric(rn_vec)
          roc_obj <- roc(
            response = responder_all[rn_vec],
            predictor = prob_mat[, "z2"],
            direction = "<"
          )
          auc_val <- as.numeric(roc_obj$auc)
          # get fisher's AUC now, too
          auc_fisher <- fishers_auc(
            .data = data_all, status = responder_all
          )
        } else {
          auc_val <- NA
        }
        # Save results
        results_auc_active <- rbind(results_auc_active, 
                            data.frame(spike_props = spike,
                                        magnitude_spikes = magnitude,
                                        AUC = auc_val,
                                        AUC_Fisher = auc_fisher,
                                        method = mtd,
                                        run = run)
        )
        results_pseudo_active <- rbind(results_pseudo_active,
                                data.frame(spike_props = spike,
                                          magnitude_spikes = magnitude,
                                          PseudoRatioStim = pseudo_ratio_stim,
                                          PseudoRatioUnstim = pseudo_ratio_uns,
                                          method = mtd,
                                          run = run))
        rm(fit, mimosa_obj, res, E, data_all)
        gc()
      }
      print("------")
    }
    print("======")
  }
}
```

Use the EM algorithm plots for the pseudo-trials ratio (as it 
estimates the parameters directly), and the AUC plots for the MCMC method
(as there are fewer failed fits).

```{r}
for (mtd in mtd_vec) {
  # Plot  AUC vs Proportion of Spikes
  plot_tbl_auc <- results_auc_active |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(AUC = mean(AUC, na.rm = TRUE), .groups = "drop") |>
    dplyr::ungroup() |>
    dplyr::filter(!is.nan(AUC)) 
  plot_auc <- ggplot(plot_tbl_auc, aes(x = spike_props, y = AUC, color = factor(magnitude_spikes))) +
    geom_line(na.rm=TRUE) +
    labs(title = "AUC vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "AUC",
        color = "Magnitude") + 
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    )
  # Plot Pseudo-cells ratio vs Proportion of Spikes 
  plot_tbl_pseudo_stim <- results_pseudo_active |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(PseudoRatioStim = mean(PseudoRatioStim, na.rm = TRUE), .groups = "drop") |>
    dplyr::ungroup() |>
    dplyr::filter(!is.nan(PseudoRatioStim))
  max_ratio <- plot_tbl_pseudo_stim$PseudoRatioStim |> max(na.rm = TRUE)
  max_log <- ceiling(log10(max_ratio))
  min_ratio <- plot_tbl_pseudo_stim$PseudoRatioStim |> min(na.rm = TRUE)
  min_log <- floor(log10(min_ratio))
  break_vec <- seq(min_log, max_log, by = 1)
  plot_pseudo_stim <- ggplot(plot_tbl_pseudo_stim, aes(x = spike_props, y = PseudoRatioStim, color = factor(magnitude_spikes))) +
    geom_line(na.rm=TRUE) +
    labs(title = "Pseudo-trials ratio vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "Number of Pseudo cells/Real cells",
        color = "Magnitude") +
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    ) +
    scale_y_continuous(
      trans = "log10",
      breaks = 10^break_vec,
      labels = scales::comma(10^break_vec),
      limits = c(10^break_vec[1], 10^max(break_vec))
    )


  # Plot Pseudo-cells ratio vs Proportion of Spikes
  plot_tbl_pseudo_uns <- results_pseudo_actve |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(PseudoRatioUnstim = mean(PseudoRatioUnstim, na.rm = TRUE), .groups = "drop") |>
    dplyr::ungroup() |>
    dplyr::filter(!is.nan(PseudoRatioUnstim))
  max_ratio_uns <- plot_tbl_pseudo_uns$PseudoRatioUnstim |> max(na.rm = TRUE)
  max_log_uns <- ceiling(log10(max_ratio_uns))
  min_ratio_uns <- plot_tbl_pseudo_uns$PseudoRatioUnstim |> min(na.rm = TRUE)
  min_log_uns <- floor(log10(min_ratio_uns))
  break_vec_uns <- seq(min_log_uns, max_log_uns, by = 1)
  plot_pseudo_uns <- ggplot(plot_tbl_pseudo_uns, aes(x = spike_props, y = PseudoRatioUnstim, color = factor(magnitude_spikes))) +
    geom_line(na.rm=TRUE) +
    labs(title = "Pseudo-trials ratio vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "Number of Pseudo cells/Real cells",
        color = "Magnitude") +
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    ) +
    scale_y_continuous(
      trans = "log10",
      breaks = 10^break_vec_uns,
      labels = scales::comma(10^break_vec_uns),
      limits = c(10^break_vec_uns[1], 10^max(break_vec_uns))
    )
  # Save
  ggsave(paste0("plots/plot_active_", mtd, "_auc.png"), plot = plot_auc, width = 6, height = 4, dpi = 300)
  ggsave(paste0("plots/plot_active_", mtd, "_pseudo_stim_.png"), plot = plot_pseudo_stim, width = 6, height = 4, dpi = 300)
  ggsave(paste0("plots/plot_active_", mtd, "_pseudo_uns_.png"), plot = plot_pseudo_uns, width = 6, height = 4, dpi = 300)
}
```

Now, we consider spiking in data where some resting samples have higher responses than others, perhaps due to pre-existing responses..
We use exactly the same code as before, except that now we only allow the magnitude of the spike to be randomly swopped for resting samples.
We vary the proportion of samples spiked from 0% to 50% (higher range, as now this is not random swopout but targeted to resting samples only, who
may in real life has this sort of distribution due to e.g. prior exposure) and the magnitude of the spike from the normal resting mean to the normal
activated mean.
To make this work better, we use more samples (N=100).

```{r}
n_samples_resting <- 100
magnitude_spikes_resting <- mu_u_NR * seq_len(5) 
spike_props_resting <- c(0, 0.05, 0.1, 0.2, 0.5)    # Proportion of spiked samples
results_auc_resting <- data.frame()
results_pseudo_resting <- data.frame()
if (run_fast) {
  spike_props <- spike_props[[1]]
  magnitude_spikes <- magnitude_spikes[[1]]
  mtd_vec <- "EM"
}
for (mtd in mtd_vec) {
  print(paste0("Method: ", mtd))
  for (spike in spike_props_resting) {
    print(paste0("spike: ", spike))
    for (magnitude in magnitude_spikes_resting) {
      print(paste0("magnitude: ", magnitude))
      for (run in seq_len(n_runs)) {
        print(paste0("run: ", run))
        mu_u_NR <- base_mu_u_NR
        mu_u_R  <- base_mu_u_R
        n_spike <- round(n_samples_resting * spike)
        # Normal data 
        params <- calculate_params(mu_u_NR, mu_u_NR, f, c_u, c_s)
        dat <- simulate_data(n_spike, w, params, N, run)
        data_all <- dat$data
        responder_all <- dat$responder_status
        # Spiked data 
        # Spiked data (only if n_spike > 0)
        if (n_spike > 0) {
          # only select stimulated indices, from responders
          rep_ind <- sample(seq(n_samples_resting + 1, n_samples_resting * 2), size = n_spike, replace = FALSE)
          data_all <- dat$data
          data_all[rep_ind, "CYTNUM"] <- rbinom(n = n_spike, size = N, prob = magnitude)
          data_all[rep_ind, "NSUB"] <- N - data_all[["CYTNUM"]][rep_ind]
          responder_all <- dat$responder_status
        }
        # Fit MIMOSA 
        E <- prepare_for_mimosa(data_all)
        fit <- fit_MIMOSA(E, mtd = mtd)
        mimosa_obj <- fit$IL2
        res <- mimosa_obj@result
        em_failure <- mtd == "EM" && "params" %in% slotNames(res)
        if (em_failure) {
          beta_stim <- NA
          alpha_stim <- NA
          pseudo_ratio_stim <- NA
          beta_uns <- NA
          alpha_uns <- NA
          pseudo_ratio_uns <- NA
        } else if (mtd == "mcmc") {
          param_values <- res@params
          alpha_stim <- param_values[2, "alphas.1"]
          beta_stim  <- param_values[2, "alphas.0"]
          # Pseudo-trials ratio 
          pseudo_ratio_stim <- (alpha_stim + beta_stim - 2) / N
          # Pseudo-trials ratio 
          alpha_uns <- param_values[2, "alphau.1"]
          beta_uns  <- param_values[2, "alphau.0"]
          pseudo_ratio_uns <- (alpha_uns + beta_uns - 2) / N
        } else if (mtd == "EM") {
          stim_vec_par <- res@par.stim
          beta_stim <- stim_vec_par[1]
          alpha_stim <- stim_vec_par[2]
          pseudo_ratio_stim <- (alpha_stim + beta_stim - 2) / N
          uns_vec_par <- res@par.unstim
          beta_stim <- uns_vec_par[1]
          alpha_stim <- uns_vec_par[2]
          pseudo_ratio_uns <- (alpha_stim + beta_stim - 2) / N
        }
        # browser()
        # AUC (using true labels: 0=normal, 1=spike) 
        labels <- c(rep(0, n_normal), rep(1, n_spike))
        # Get posterior probability that each sample is a responder
        prob_mat <- res@z
        if (length(unique(labels)) > 1 && !em_failure) {
          rn_vec <- rownames(prob_mat)
          rn_vec <- gsub("Treatment_Subject_", "", rn_vec)
          rn_vec <- gsub("_IL2.*", "", rn_vec)
          rn_vec <- as.numeric(rn_vec)
          roc_obj <- roc(
            response = responder_all[rn_vec],
            predictor = prob_mat[, "z2"],
            direction = "<"
          )
          auc_val <- as.numeric(roc_obj$auc)
          # get fisher's AUC now, too
          auc_fisher <- fishers_auc(
            .data = data_all, status = responder_all
          )
        } else {
          auc_val <- NA
        }
        # Save results
        results_auc_resting <- rbind(results_auc_resting, 
                            data.frame(spike_props = spike,
                                        magnitude_spikes = magnitude,
                                        AUC = auc_val,
                                        AUC_Fisher = auc_fisher,
                                        method = mtd,
                                        run = run)
        )
        results_pseudo_resting <- rbind(results_pseudo_resting,
                                data.frame(spike_props = spike,
                                          magnitude_spikes = magnitude,
                                          PseudoRatioStim = pseudo_ratio_stim,
                                          PseudoRatioUnstim = pseudo_ratio_uns,
                                          method = mtd,
                                          run = run))
        rm(fit, mimosa_obj, res, E, data_all)
        gc()
      }
      print("------")
    }
    print("======")
  }
}
```

Use the EM algorithm plots for the pseudo-trials ratio (as it 
estimates the parameters directly), and the AUC plots for the MCMC method
(as there are fewer failed fits).

```{r}
for (mtd in mtd_vec) {
  # Plot  AUC vs Proportion of Spikes
  plot_tbl_auc <- results_auc_resting |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(AUC = mean(AUC, na.rm = TRUE), .groups = "drop") |>
    dplyr::ungroup() |>
    dplyr::filter(!is.nan(AUC)) 
  plot_auc <- ggplot(plot_tbl_auc, aes(x = spike_props, y = AUC, color = factor(magnitude_spikes))) +
    geom_line(na.rm=TRUE) +
    labs(title = "AUC vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "AUC",
        color = "Magnitude") + 
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    )
  # Plot Pseudo-cells ratio vs Proportion of Spikes 
  plot_tbl_pseudo_stim <- results_pseudo_resting |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(PseudoRatioStim = mean(PseudoRatioStim, na.rm = TRUE), .groups = "drop") |>
    dplyr::ungroup() |>
    dplyr::filter(!is.nan(PseudoRatioStim))
  max_ratio <- plot_tbl_pseudo_stim$PseudoRatioStim |> max(na.rm = TRUE)
  max_log <- ceiling(log10(max_ratio))
  min_ratio <- plot_tbl_pseudo_stim$PseudoRatioStim |> min(na.rm = TRUE)
  min_log <- floor(log10(min_ratio))
  break_vec <- seq(min_log, max_log, by = 1)
  plot_pseudo_stim <- ggplot(plot_tbl_pseudo_stim, aes(x = spike_props, y = PseudoRatioStim, color = factor(magnitude_spikes))) +
    geom_line(na.rm=TRUE) +
    labs(title = "Pseudo-trials ratio vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "Number of Pseudo cells/Real cells",
        color = "Magnitude") +
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    ) +
    scale_y_continuous(
      trans = "log10",
      breaks = 10^break_vec,
      labels = scales::comma(10^break_vec),
      limits = c(10^break_vec[1], 10^max(break_vec))
    )


  # Plot Pseudo-cells ratio vs Proportion of Spikes
  plot_tbl_pseudo_uns <- results_pseudo_actve |>
    dplyr::filter(method == mtd) |>
    dplyr::group_by(spike_props, magnitude_spikes) |>
    dplyr::summarise(PseudoRatioUnstim = mean(PseudoRatioUnstim, na.rm = TRUE), .groups = "drop") |>
    dplyr::ungroup() |>
    dplyr::filter(!is.nan(PseudoRatioUnstim))
  max_ratio_uns <- plot_tbl_pseudo_uns$PseudoRatioUnstim |> max(na.rm = TRUE)
  max_log_uns <- ceiling(log10(max_ratio_uns))
  min_ratio_uns <- plot_tbl_pseudo_uns$PseudoRatioUnstim |> min(na.rm = TRUE)
  min_log_uns <- floor(log10(min_ratio_uns))
  break_vec_uns <- seq(min_log_uns, max_log_uns, by = 1)
  plot_pseudo_uns <- ggplot(plot_tbl_pseudo_uns, aes(x = spike_props, y = PseudoRatioUnstim, color = factor(magnitude_spikes))) +
    geom_line(na.rm=TRUE) +
    labs(title = "Pseudo-trials ratio vs Proportion of Spikes",
        x = "Proportion of Spikes",
        y = "Number of Pseudo cells/Real cells",
        color = "Magnitude") +
    cowplot::theme_cowplot() +
    theme(
      plot.background = element_rect(fill = "white", colour = "white"),
      panel.background = element_rect(fill = "white", colour = "white")
    ) +
    scale_y_continuous(
      trans = "log10",
      breaks = 10^break_vec_uns,
      labels = scales::comma(10^break_vec_uns),
      limits = c(10^break_vec_uns[1], 10^max(break_vec_uns))
    )
  # Save
  ggsave(paste0("plots/plot_resting_", mtd, "_auc.png"), plot = plot_auc, width = 6, height = 4, dpi = 300)
  ggsave(paste0("plots/plot_resting_", mtd, "_pseudo_stim_.png"), plot = plot_pseudo_stim, width = 6, height = 4, dpi = 300)
  ggsave(paste0("plots/plot_resting_", mtd, "_pseudo_uns_.png"), plot = plot_pseudo_uns, width = 6, height = 4, dpi = 300)
}
```
